\section{Design}
\label{sec:design}
%\subsection*{Assumptions}
%	short-running processes will have their battery usage amortized over longer running apps.
% could check all apps (instead of just running apps at snapshot),
% but balance between WH's power usage and ability to provide useful info to end user.
% 
% Assume that apps that use significant power will be spotted eventually, unless waking up on strictly opposite cycle.
% Assume short-term information more informative than historic view -- analyzer assumes current behavior will continue
% analyzer examines CPU and network I/O.  Due to time constraints, these metrics are currently separated.  Future work could provide a unified metric of usage.

%%
% why do we believe we will eventually see short-running apps?
% because if they're drawing significant battery and we don't see them,
% chances are high the app is 'hiding' itself from WH
% since apps that 
% 1) short term apps get bg'd not killed
% 2) most apps are user-driven, so not strictly cyclical (so not opp WH cycle)
% 3) in general, short-term apps won't use much power
%     so for power depletion to be significant, must run very frequently
% energy draw is amortized over all running apps

The \emph{Watt's Happening} application provides an estimate of remaining battery time, based on current and historic resource usage metrics. 
This estimate is provided along with a list of the currently running applications, weighted based on resource usage metrics.  
This provides the user with information that can be used to terminate a running application, thereby lengthening remaining battery time.
The resource usage metrics are calculated on a per-application basis.
The resources examined include CPU and network I/O.
The reason to choose these resources for examination is twofold: the ease of measurement, and the high correlation between the usage of these resources and battery draw.

In order to obtain metrics on resource usage, data is gathered from the underlying operating system.
The status of hardware devices including radio states, location, screen state, and battery levels is queried and retained.
Currently running applications and resource consumption metrics are also queried and retained. 
Hardware use is attributed to each application based on application resource consumption metrics. 
Battery drain is attributed to hardware states.
Use of hardware allows allocation of battery consumption across applications.
Of course, the act of measuring carries the risk of excessive power draw; we attempt to obtain representative data collection in a conservative manner.
Performing this balance does allow the possibility that short-running applications will not be seen by the \emph{Watt's Happening} logger.
We assume that short-running applications that account for significant battery draw will eventually appear to our logger.
Applications that are not visible to our logger certainly still draw battery, but this usage, by necessity, will be amortized over applications that are visible.

\emph{Watt's Happening} provides a battery life estimate based on rate of usage in conjunction with battery level remaining.
This estimate is strongly biased in favor of recent activity, while still incorporating long-term historic usage. 
Since the battery consumption rate is derived from the assumption that the current usage pattern will continue, recent activities will yield a more conservative estimation of future use.
%We use this assumption to find 
The reported time remaining should be conservative because user expectation dictates that the battery will last at least as long as the \emph{Watt's Happening} estimate.

%In the case of no change in the battery level during a short term snapshot, a longterm averaged estimate is used.

If the user desires to prolong their battery further than the estimate, \emph{Watt's Happening} presents a set of lists showing running applications sorted by respective resource usage.
Usage is directly tied to battery draw as described above. 
This allows the user to select what action to take (i.e., termination of one or more applications) to extend battery life by drawing attention to applications that are (i) currently running and (ii) drawing proportionally significant power.


%Time-biased battery life estimate 


%%%%%
%Before starting on the application, we made two design assumptions.  
%First, any services that end quickly will not be incorporated into the analysis.  
%We assume that only long running programs will have a significant effect on the overall battery usage.  
%There exists the possibility for short, intense applications to game the system by terminating before our application's polling, but we ignore that possibility for now.  
%The second assumption is that we only display candidate applications for termination if they are currently running.  
%TODO 
%Future variation of the program can implement features that inform the user how much longer they can run their favorite applications while still reaching their target, but currently we limit our focus.

